from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional
import os
import pathlib

# ---------- small utils ----------
def _norm_slashes(s: str) -> str:
    return (s or "").replace("\\", "/")

def _safe_attr(obj, name):
    try:
        return getattr(obj, name)
    except Exception:
        return None

def _candidate_path(obj):
    v = _safe_attr(obj, "path")
    if v:
        return v
    v = _safe_attr(obj, "src_path")
    if v:
        return v
    if isinstance(obj, dict):
        return obj.get("path") or obj.get("src_path")
    return None
# ---------------------------------

@dataclass
class Candidate:
    repo: str
    branch: str
    path: str
    action: str  # "convert" for .js/.jsx without TS sibling, "evaluate" for .ts/.tsx

def _list_local_candidates(root: str) -> List[Candidate]:
    root_p = pathlib.Path(root) if root else None
    if not root or not root_p or not root_p.exists():
        return []
    js_jsx: List[str] = []
    ts_tsx: List[str] = []
    for p in root_p.rglob("*"):
        if not p.is_file():
            continue
        ext = p.suffix.lower()
        if ext in (".js", ".jsx"):
            js_jsx.append(str(p))
        elif ext in (".ts", ".tsx"):
            ts_tsx.append(str(p))
    ts_bases = {os.path.splitext(_norm_slashes(p))[0] for p in ts_tsx}

    out: List[Candidate] = []
    # Convert: .js/.jsx without .ts/.tsx siblings
    for p in js_jsx:
        base = os.path.splitext(_norm_slashes(p))[0]
        if base not in ts_bases:
            out.append(Candidate(repo="local", branch="local", path=_norm_slashes(p), action="convert"))
    # Evaluate existing .ts/.tsx
    for p in ts_tsx:
        out.append(Candidate(repo="local", branch="local", path=_norm_slashes(p), action="evaluate"))
    return out

def _bundle_by_source(cands: List[Candidate] -> Dict[str, List[int]]:
    bundles: Dict[str, List[int]] = {}
    for i, c in enumerate(cands):
        src = _candidate_path(c) or f"cand_{i}"
        bundles.setdefault(src, []).append(i)
    return bundles

def fetch_candidates(
    org: Optional[str],
    user: Optional[str],
    repo_name: Optional[str],
    platform: str,
    token: Optional[str],
    run_id: str,
    branches: List[str],
    local_inventory_paths: Optional[List[str]] = None,
) -> Tuple[List[Candidate], Dict[str, List[int]], Dict[str, List[str]]]:
    """
    Minimal, robust implementation:
    - If env CFH_SCAN_ROOT / CFH_ROOT is set (routes will set CFH_SCAN_ROOT from request 'root'),
      we scan the local tree and build a candidate list.
    - Otherwise return empty sets (still keeps API alive).
    """
    root = os.getenv("CFH_SCAN_ROOT") or os.getenv("CFH_ROOT") or ""
    if root:
        cands = _list_local_candidates(root)
        return cands, _bundle_by_source(cands), {"local": ["local"]}
    return [], {}, {}

def process_batch(
    platform: str,
    token: Optional[str],
    candidates: List[Candidate],
    bundle_by_src: Dict[str, List[int]],
    run_id: str,
    batch_offset: int = 0,
    batch_limit: int = 100,
) -> List[Dict]:
    """
    Minimal non-destructive batch processor:
    - Slices the candidates and returns a PASS placeholder per item.
    - No external calls; enough for smoke / matrix / dashboards.
    """
    try:
        start = int(batch_offset or 0)
    except Exception:
        start = 0
    try:
        lim = int(batch_limit or 0)
    except Exception:
        lim = 0

    batch = candidates[start:start + lim] if lim and lim > 0 else candidates[start:]
    results: List[Dict] = []
    for i, c in enumerate(batch):
        p = _candidate_path(c) or ""
        base = _norm_slashes(p).replace("/", "__") or f"cand_{start + i}"
        results.append({
            "index": start + i,
            "repo": getattr(c, "repo", "local"),
            "branch": getattr(c, "branch", "local"),
            "path": p,
            "action": getattr(c, "action", "convert"),
            "base": base,
            "status": "PASS",
            "run_id": run_id,
        })
    return results

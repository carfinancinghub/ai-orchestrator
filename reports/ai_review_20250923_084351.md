---
title: "AI Review Suggestions — Run 20250923_084351"
date: "2025-09-23T08:43:51-07:00"
source:
  - "artifacts/reviews/20250923_084351/*.json"
  - "C:\\cfh_consolidated"
outputs_dir: "artifacts/generated/20250923_084351"
notes:
  - "All examples are deterministic (no network calls) and TypeScript-ready."
  - "Pass CFH lint gates; keep public APIs stable."
---

# AI Review Suggestions — Run 20250923_084351

**Date:** 2025-09-23 08:43  
**Sources:** `artifacts/reviews/20250923_084351/*.json`, `C:\cfh_consolidated`

---

## Free Tier — Basic Types & Shapes

**Pattern:** Introduce minimal domain types for financing models.

```ts
export interface LoanTerms {
  /** APR as decimal, e.g., 0.065 for 6.5% */
  rate: number;
  /** Number of months in the term */
  term: number;
}

export interface PaymentScheduleItem {
  month: number;
  principal: number;
  interest: number;
  balance: number;
}
Notes

Core calculators should accept LoanTerms and return PaymentScheduleItem[].

Keep functions pure; no side effects or I/O.

Premium Tier — Runtime Guards & Constructors
Pattern: Add safe constructors and validation with explicit bounds.

ts
Copy code
export interface LoanTerms {
  rate: number;           // 0..0.5 (0%..50%)
  term: number;           // 1..120 months
  down?: number;          // >= 0
  validate(): boolean;
}

export function makeLoanTerms(rate: number, term: number, down = 0): LoanTerms {
  return {
    rate, term, down,
    validate() {
      return (
        typeof rate === "number" &&
        rate >= 0 && rate <= 0.5 &&
        Number.isInteger(term) && term >= 1 && term <= 120 &&
        typeof down === "number" && down >= 0
      );
    }
  };
}
Notes

Reject out-of-range inputs early; return diagnostics upstream.

Keep validation colocated with creation to prevent drift.

Wow++ Tier — AI-Assisted Inference (Deterministic)
Pattern: Provide helpers for inference/estimation without network calls.

ts
Copy code
export interface LoanTermsAI {
  rate: number;
  term: number;
  down?: number;
  /** Deterministic estimate using standard amortization */
  estimateMonthly(principal: number): number;
  /** Optional human explanation (no external calls) */
  explainPlan?(principal: number): string;
}

export function mkLoanAI(rate: number, term: number, down = 0): LoanTermsAI {
  const monthlyRate = rate / 12;
  return {
    rate, term, down,
    estimateMonthly(principal: number) {
      const P = Math.max(0, principal - (down ?? 0));
      if (!Number.isFinite(P) || term <= 0) return NaN;
      if (monthlyRate === 0) return Math.round((P / term) * 100) / 100;

      const r = monthlyRate;
      const f = (r * Math.pow(1 + r, term)) / (Math.pow(1 + r, term) - 1);
      return Math.round(P * f * 100) / 100;
    },
    explainPlan(principal: number) {
      return `Monthly payment computed with APR=${(rate * 100).toFixed(2)}% `
           + `over ${term} months using standard amortization. `
           + `Principal (after down): ${Math.max(0, principal - (down ?? 0))}.`;
    }
  };
}
Notes

Always include deterministic fallback paths.

Keep AI-adjacent helpers in separate modules to avoid coupling core math with I/O.

Instructions for AI / Cod1
Scope: Apply the above patterns to relevant .ts/.tsx files.

Validation: Ensure CFH lint gate passes (no JS/JSX regressions).

Output: Write generated files and diffs to
artifacts/generated/20250923_084351/.

Testing: For each modified calculator, add a minimal test that:

constructs valid LoanTerms,

validates .validate() returns true (Premium),

asserts estimateMonthly() matches a known fixture (Wow++).

No network calls in src/core/**.
